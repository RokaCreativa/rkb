# üîß Errores y Soluciones en RokaMenu

Este documento registra errores comunes, sus causas y soluciones implementadas en el proyecto RokaMenu. Sirve como referencia para resolver problemas recurrentes y evitar repetir errores.

## üîÑ Problemas de Tipos y Conversiones

### Error: Inconsistencia de Tipos Booleanos vs. Num√©ricos

**Descripci√≥n**: 
Los campos de estado como `status` y `deleted` se manejan de manera inconsistente en diferentes partes de la aplicaci√≥n:
- En la base de datos: como `BOOLEAN` o `TINYINT(1)`
- En la API: a veces como booleanos, a veces como n√∫meros
- En el frontend: esperados como 0/1 (num√©ricos)

**Causa**:
Falta de estandarizaci√≥n en el manejo de tipos y conversiones entre frontend y backend.

**Soluci√≥n**:
1. Estandarizar el uso de tipos seg√∫n documentaci√≥n en `estandares-tipos.md`
2. En endpoints de API, convertir expl√≠citamente:
   ```typescript
   // Convertir booleano de BD a num√©rico para frontend
   return {
     ...entity,
     status: entity.status ? 1 : 0
   };
   ```
3. Implementar adaptadores para conversiones sistem√°ticas:
   ```typescript
   // lib/adapters/category-adapter.ts
   export function adaptHookCategoryToDashboard(category: HookCategory): DashboardCategory {
     return {
       ...category,
       status: category.status ? 1 : 0
     };
   }
   ```

## üóÑÔ∏è Problemas con Operaciones CRUD

### Error: No se puede editar productos despu√©s de cambios de tipo

**Descripci√≥n**:
Despu√©s de refactorizar los tipos, las operaciones de edici√≥n de productos dejaron de funcionar.

**S√≠ntomas**:
- El endpoint `/api/products/[id]` devuelve error 500
- Mensaje de error: "Cannot read properties of undefined (reading 'status')"

**Causa**:
El campo `deleted` se trataba incorrectamente como num√©rico en lugar de booleano en el endpoint de productos:

```typescript
// C√≥digo incorrecto en route.ts
deleted: 0 as any
```

**Soluci√≥n**:
Cambiar para usar el tipo correcto:

```typescript
// C√≥digo corregido
deleted: false
```

### Error: Elementos no se muestran despu√©s de cambiar el estado

**Descripci√≥n**:
Al cambiar la visibilidad de categor√≠as, secciones o productos, a veces los cambios no se reflejan inmediatamente en la UI.

**Causa**:
Actualizaci√≥n optimista de la UI sin confirmar cambios con el servidor.

**Soluci√≥n**:
1. Implementar patr√≥n de actualizaci√≥n optimista con rollback:
   ```typescript
   const toggleVisibility = async (id, currentStatus) => {
     // 1. Guardar estado anterior
     const previousData = [...currentData];
     
     // 2. Actualizar UI optimistamente
     setCurrentData(data => data.map(item => 
       item.id === id ? {...item, status: currentStatus === 1 ? 0 : 1} : item
     ));
     
     try {
       // 3. Enviar cambio al servidor
       await api.updateStatus(id, currentStatus === 1 ? 0 : 1);
     } catch (error) {
       // 4. Si falla, revertir al estado anterior
       setCurrentData(previousData);
       showErrorMessage("No se pudo actualizar el estado");
     }
   };
   ```

## üåê Problemas de Carga de Datos

### Error: Tiempo de carga excesivo del dashboard

**Descripci√≥n**:
El dashboard tardaba m√°s de 20 segundos en cargar para men√∫s con muchas categor√≠as, secciones y productos.

**Causa**:
Precarga agresiva de todos los datos al iniciar, incluyendo:
- Todas las categor√≠as
- Todas las secciones de todas las categor√≠as
- Todos los productos de todas las secciones

**Soluci√≥n**:
1. Implementar carga bajo demanda:
   - Cargar inicialmente solo categor√≠as
   - Cargar secciones cuando se expande una categor√≠a
   - Cargar productos cuando se expande una secci√≥n

2. Implementar paginaci√≥n:
   ```typescript
   // API con paginaci√≥n
   export async function getCategories(page = 1, limit = 10) {
     const skip = (page - 1) * limit;
     const [data, total] = await Promise.all([
       prisma.categories.findMany({
         where: { deleted: 0 },
         skip,
         take: limit,
         orderBy: { display_order: 'asc' }
       }),
       prisma.categories.count({ where: { deleted: 0 } })
     ]);
     
     return {
       data,
       pagination: {
         total,
         pages: Math.ceil(total / limit),
         current: page
       }
     };
   }
   ```

**Resultados**:
- Tiempo de carga inicial reducido a menos de 2 segundos
- Experiencia de usuario m√°s fluida
- Menor carga en el servidor

## üß© Problemas con Componentes

### Error: Errores de renderizado por componentes duplicados

**Descripci√≥n**:
Errores de React relacionados con la renderizaci√≥n de componentes, especialmente con modales.

**S√≠ntomas**:
- Warnings en consola sobre prop drilling
- Problemas al abrir/cerrar modales
- Comportamiento impredecible en formularios

**Causa**:
M√∫ltiples implementaciones de los mismos componentes con ligeras variaciones.

**Soluci√≥n**:
1. Consolidar componentes duplicados:
   - Crear componentes base reutilizables (`BaseModal`, `FormModal`, etc.)
   - Extender funcionalidad mediante composici√≥n en lugar de duplicaci√≥n

2. Implementar sistema unificado de modales:
   ```typescript
   // Uso del sistema unificado
   const { showModal, hideModal } = useModalState();
   
   // Para mostrar un modal
   showModal('deleteCategory', { categoryId: 123 });
   
   // En el componente orquestador
   const modalConfig = {
     deleteCategory: {
       component: DeleteCategoryModal,
       title: "Eliminar Categor√≠a"
     },
     // Otros modales...
   };
   ```

## üîÑ Problemas con Refactorizaci√≥n

### Error: Funcionalidad rota despu√©s de extraer l√≥gica

**Descripci√≥n**:
Al mover c√≥digo a nuevos servicios o hooks, algunas funcionalidades dejaron de funcionar.

**S√≠ntomas**:
- Eventos que no se disparan
- Datos que no se actualizan
- Referencias indefinidas

**Causas**:
1. Referencias perdidas a variables de estado o funciones
2. Ciclo de vida de hooks no respetado
3. Contexto (`this`) perdido en funciones

**Soluci√≥n**:
1. Implementar refactorizaci√≥n gradual con enfoque en compatibilidad:
   ```typescript
   // En el componente original
   const oldFunction = useCallback(() => {
     // Llamar a la nueva implementaci√≥n mientras mantenemos la interfaz antigua
     return newService.newFunction(...args);
   }, [newService]);
   ```

2. Usar adaptadores para mantener compatibilidad:
   ```typescript
   // lib/adapters/category-functions-adapter.ts
   export function adaptToggleCategoryVisibility(
     hookToggleVisibility: (id: number, currentStatus: boolean) => Promise<void>
   ) {
     return async (
       categoryId: number, 
       currentStatus: number, 
       categories: Category[], 
       setCategories: (categories: Category[]) => void
     ) => {
       // L√≥gica de adaptaci√≥n
       await hookToggleVisibility(categoryId, currentStatus === 1);
     };
   }
   ```

## üìã Problemas Espec√≠ficos de Entidades

### Error: No se pueden eliminar categor√≠as con secciones

**Descripci√≥n**:
Al intentar eliminar una categor√≠a que contiene secciones, la operaci√≥n falla.

**Causa**:
Falta de manejo de eliminaci√≥n en cascada o validaci√≥n apropiada.

**Soluci√≥n**:
1. Implementar eliminaci√≥n en cascada en la base de datos:
   ```prisma
   model sections {
     // Otros campos...
     categories categories? @relation(fields: [category_id], references: [category_id], onDelete: Cascade)
   }
   ```

2. Si no es posible la eliminaci√≥n en cascada, implementar validaci√≥n:
   ```typescript
   async function deleteCategory(id) {
     // Verificar si tiene secciones
     const sectionsCount = await prisma.sections.count({
       where: { category_id: id }
     });
     
     if (sectionsCount > 0) {
       throw new Error("No se puede eliminar una categor√≠a con secciones. Elimine primero las secciones.");
     }
     
     // Continuar con la eliminaci√≥n
   }
   ```

## üì± Problemas de Experiencia de Usuario

### Error: Interfaz bloqueada durante carga de datos

**Descripci√≥n**:
La interfaz se bloquea durante la carga inicial, mostrando una pantalla en blanco o un spinner.

**Causa**:
Carga s√≠ncrona de datos grandes que bloquea el hilo principal.

**Soluci√≥n**:
1. Implementar carga progresiva y componentes de skeleton:
   ```tsx
   function ProductList() {
     const { products, isLoading } = useProducts();
     
     return (
       <div>
         {isLoading ? (
           // Mostrar esqueletos mientras se carga
           Array.from({ length: 5 }).map((_, index) => (
             <ProductSkeleton key={index} />
           ))
         ) : (
           products.map(product => (
             <ProductItem key={product.id} product={product} />
           ))
         )}
       </div>
     );
   }
   ```

2. Implementar indicadores de carga para acciones individuales:
   ```tsx
   function DeleteButton({ onDelete, itemId }) {
     const [isDeleting, setIsDeleting] = useState(false);
     
     const handleDelete = async () => {
       setIsDeleting(true);
       try {
         await onDelete(itemId);
       } finally {
         setIsDeleting(false);
       }
     };
     
     return (
       <button 
         onClick={handleDelete} 
         disabled={isDeleting}
       >
         {isDeleting ? "Eliminando..." : "Eliminar"}
       </button>
     );
   }
   ```

## üìö Registro de Errores Recientes

### Abril 2024: Correcci√≥n de Tipos en Endpoint de Productos

**Problema**: La edici√≥n de productos fallaba con error 500.

**An√°lisis**: El campo `deleted` se trataba incorrectamente como num√©rico (`deleted: 0 as any`) cuando deb√≠a ser booleano (`deleted: false`).

**Soluci√≥n implementada**: Corregido el tipo en `app/api/products/[id]/route.ts` para usar el tipo booleano correcto para el campo `deleted`.

**Estado**: ‚úÖ Resuelto

### Marzo 2024: Optimizaci√≥n de Carga Inicial

**Problema**: Tiempos de carga excesivos (20+ segundos) para el dashboard.

**An√°lisis**: Precarga agresiva de todos los datos, incluyendo categor√≠as, secciones y productos.

**Soluci√≥n implementada**: 
1. Implementaci√≥n de carga bajo demanda
2. Cargar secciones y productos solo cuando se necesitan

**Estado**: ‚úÖ Resuelto

## üí° Mejores Pr√°cticas para Evitar Errores

1. **Validar datos** antes de enviarlos a la API
2. **Estandarizar tipos** seg√∫n la documentaci√≥n
3. **Usar interfaces** TypeScript para definir claramente contratos
4. **Implementar manejo de errores** en todas las operaciones as√≠ncronas
5. **Evitar duplicaci√≥n de c√≥digo** mediante componentes y hooks reutilizables
6. **Utilizar comentarios explicativos** para c√≥digo complejo
7. **Seguir patrones establecidos** en el proyecto
8. **Realizar pruebas manuales** despu√©s de cada cambio significativo

---

Este documento se actualizar√° continuamente a medida que se identifiquen y resuelvan nuevos problemas. Si encuentras un error no documentado, por favor a√±√°delo siguiendo el formato establecido. 