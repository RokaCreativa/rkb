**Objetivo:** Test de flujo "seleccionar categoría → sección → añadir producto".

// **tests**/dashboardFlow.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event'; // Para interacciones más realistas
import { useDashboardStore } from '../store/dashboardStore'; // Tu store real
import { DashboardClient } from '../components/DashboardClient'; // O el componente principal que usa el store
// Mockear la API
jest.mock('../api', () => ({ // Asume que tienes un archivo api.ts
\__esModule: true,
default: {
fetchInitialData: jest.fn().mockResolvedValue({
categories: [{ id: 'cat1', name: 'Comidas' }],
sections: [{ id: 'sec1', name: 'Entrantes', categoryId: 'cat1' }],
products: [],
}),
addProductToSection: jest.fn().mockImplementation(async (sectionId, productData) => ({
...productData,
id: `prod_${Date.now()}`,
parentId: sectionId,
parentType: 'section',
})),
},
}));

// Helper para resetear el store entre tests si es necesario
const originalState = useDashboardStore.getState();
beforeEach(() => {
useDashboardStore.setState(originalState, true); // Reset to initial state
// O, si tu store tiene una acción de reset:
// useDashboardStore.getState().reset();
});

describe('Dashboard Flow: Add Product', () => {
test('should allow adding a product to a section after selecting category and section', async () => {
const user = userEvent.setup();
render(<DashboardClient />); // Asume que DashboardClient carga los datos iniciales

    // 1. Esperar carga inicial (ajusta según tu UI)
    await waitFor(() => expect(screen.getByText('Comidas')).toBeInTheDocument());

    // 2. Seleccionar Categoría "Comidas" (ajusta el selector a tu UI)
    // Esto asume que tienes un botón o un elemento clickeable para "Comidas"
    // que actualiza selectedCategoryId en el store.
    // En tu UI de 3 columnas, esto sería un clic en la primera columna.
    // Para este test, podríamos necesitar simular la acción que actualiza el store
    // o tener un componente más granular para testear.
    // Si `DashboardClient` renderiza `CategoryGridView`, podemos hacer clic ahí.

    // Simulación simplificada: Asumimos que al hacer clic en "Comidas",
    // la UI se actualiza para mostrar "Entrantes".
    // En una UI real, esto podría ser:
    // fireEvent.click(screen.getByRole('button', { name: /Comidas/i }));
    // await screen.findByRole('button', { name: /Entrantes/i });

    // Para este ejemplo, vamos a simular la selección directamente en el store
    // si testear el clic es muy complejo por la estructura del componente.
    // ¡PERO ES MEJOR INTERACTUAR CON LA UI COMO LO HARÍA EL USUARIO!
    act(() => {
      useDashboardStore.setState({ selectedCategoryId: 'cat1' });
    });

    // 3. Esperar y Seleccionar Sección "Entrantes"
    const entrantesButton = await screen.findByText('Entrantes'); // Ajusta el selector
    await user.click(entrantesButton);
     act(() => {
      useDashboardStore.setState({ selectedSectionId: 'sec1' });
    });


    // 4. Abrir modal/formulario para añadir producto (ej. clic en botón "Añadir Producto")
    // const addProductButton = await screen.findByRole('button', { name: /Añadir Producto a Entrantes/i });
    // await user.click(addProductButton);

    // Simulación: Asumimos que hay un botón "Añadir Producto Test" que llama a la acción del store
    // Este botón podría ser parte de un formulario que se abre.
    // Por simplicidad, vamos a invocar la acción del store directamente para el test.
    // En un test real, interactuarías con los campos del formulario y el botón de submit.

    let newProductName = 'Papas Fritas Test';
    await act(async () => {
      // Esta es una simplificación. Normalmente, rellenarías un formulario.
      // const { addProductToSection } = useDashboardStore.getState();
      // await addProductToSection('sec1', { name: newProductName, price: '5.00' });
      // Para este ejemplo, vamos a añadirlo directamente al estado para ver el contador.
       useDashboardStore.setState(state => ({
         products: [...state.products, {id: 'p-test', name: newProductName, parentId: 'sec1', parentType: 'section', price: '5.00'}]
       }));
    });

    // 5. Verificar que el producto aparece en la lista (si la UI lo muestra)
    // await screen.findByText(newProductName);

    // 6. Verificar que un contador (si existe y es visible) se actualiza
    // Ejemplo: Si "Entrantes" muestra "(1 producto)"
    // const entrantesCounter = await screen.findByText(/Entrantes $$1 producto$$/i);
    // expect(entrantesCounter).toBeInTheDocument();

    // Ejemplo de verificación de estado del store (menos ideal que verificar la UI)
    const finalState = useDashboardStore.getState();
    const productsInSection1 = finalState.products.filter(p => p.parentId === 'sec1');
    expect(productsInSection1).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ name: newProductName })
      ])
    );
    // Verificar contador derivado (si tienes un selector para ello)
    // const section1Counts = selectSectionWithCounts('sec1')(finalState);
    // expect(section1Counts.productsCount).toBe(1);

});
});
**Notas sobre Testing con Zustand:**

- Puedes importar tu store directamente en los tests.
- `act()` de RTL es necesario cuando actualizas el estado que causa re-renders.
- Mockear APIs (con `jest.mock` o MSW) es crucial para aislar el frontend.
- Resetear el estado del store entre tests (`beforeEach`) asegura que los tests sean independientes.
- **Prioriza testear lo que el usuario ve y hace.** Verificar cambios en la UI (texto, visibilidad de elementos) es generalmente mejor que verificar el estado interno del store directamente, aunque esto último puede ser útil para depurar.
