/**
 * @fileoverview dashboardStore.ts - Store centralizado de Zustand para el estado del dashboard.
 * @description Este store es la √∫nica fuente de verdad para el dashboard.
 * Se ha restaurado su estado completo para dar servicio tanto a la vista m√≥vil como a la de escritorio,
 * y se ha corregido la l√≥gica CRUD para que sea robusta y segura en tipos.
 */
import { create } from 'zustand';
import React from 'react';
import { Category, Section, Product, Client } from '../types';
import { toast } from 'react-hot-toast';
import { getCategoryDisplayMode, isCategorySimpleMode } from '../utils/categoryUtils';

// üéØ IMPORTAR TIPOS DE PERMISOS
// PORQU√â: Necesarios para validaciones en las operaciones CRUD
import { Permission } from '../types/domain/permissions';

// --- INTERFACES ---

export interface DashboardState {
    client: Client | null;
    categories: Category[];
    sections: Record<string, Section[]>; // key: categoryId
    products: Record<string, Product[]>; // key: sectionId

    // Estados de carga y error
    isLoading: boolean;
    isClientLoading: boolean;
    isUpdating: boolean;
    error: string | null;
    initialDataLoaded: boolean;

    // Estado de UI para VISTA M√ìVIL
    activeView: 'categories' | 'sections' | 'products';
    activeCategoryId: number | null;
    activeSectionId: number | null;
    history: { view: 'categories' | 'sections' | 'products'; id: number | null }[];

    // Estado de UI para VISTA DE ESCRITORIO
    selectedCategoryId: number | null;
    selectedSectionId: number | null;

    // üéØ FASE 8: ESTADO DE PERMISOS
    // PORQU√â: Cache de validaciones para evitar rec√°lculos
    permissionCache: Record<string, boolean>;
}

export interface DashboardActions {
    initializeDashboard: (clientId: number) => Promise<void>;
    fetchCategories: (clientId: number) => Promise<void>;
    fetchSectionsByCategory: (categoryId: number) => Promise<void>;
    fetchProductsBySection: (sectionId: number) => Promise<void>;
    fetchProductsByCategory: (categoryId: number) => Promise<void>;
    fetchDataForCategory: (categoryId: number) => Promise<void>;
    
    // üéØ OPERACIONES CRUD CON VALIDACIONES
    // PORQU√â: Todas las operaciones ahora validan permisos antes de ejecutar
    createCategory: (data: Partial<Category>, imageFile?: File | null, skipPermissionCheck?: boolean) => Promise<void>;
    updateCategory: (id: number, data: Partial<Category>, imageFile?: File | null, skipPermissionCheck?: boolean) => Promise<void>;
    deleteCategory: (id: number, skipPermissionCheck?: boolean) => Promise<void>;
    toggleCategoryVisibility: (id: number, status: number, skipPermissionCheck?: boolean) => Promise<void>;
    createSection: (data: Partial<Section>, imageFile?: File | null, skipPermissionCheck?: boolean) => Promise<void>;
    updateSection: (id: number, data: Partial<Section>, imageFile?: File | null, skipPermissionCheck?: boolean) => Promise<void>;
    deleteSection: (id: number, skipPermissionCheck?: boolean) => Promise<void>;
    toggleSectionVisibility: (id: number, status: number, skipPermissionCheck?: boolean) => Promise<void>;
    createProduct: (data: Partial<Product>, imageFile?: File | null, skipPermissionCheck?: boolean) => Promise<void>;
    createProductDirect: (categoryId: number, data: Partial<Product>, imageFile?: File | null, skipPermissionCheck?: boolean) => Promise<void>;
    updateProduct: (id: number, data: Partial<Product>, imageFile?: File | null, skipPermissionCheck?: boolean) => Promise<void>;
    deleteProduct: (id: number, skipPermissionCheck?: boolean) => Promise<void>;
    toggleProductVisibility: (id: number, status: number, skipPermissionCheck?: boolean) => Promise<void>;
    
    setSelectedCategoryId: (id: number | null) => void;
    setSelectedSectionId: (id: number | null) => void;
    handleCategorySelect: (id: number) => void;
    handleSectionSelect: (id: number) => void;
    handleBack: () => void;

    // üéØ FUNCIONES DE VALIDACI√ìN INTERNA
    // PORQU√â: Validaciones centralizadas que pueden usar los componentes
    validatePermission: (permission: Permission) => boolean;
    clearPermissionCache: () => void;
}

// --- ESTADO INICIAL ---

const initialState: DashboardState = {
    client: null,
    categories: [],
    sections: {},
    products: {},
    isLoading: false,
    isClientLoading: true,
    isUpdating: false,
    error: null,
    initialDataLoaded: false,
    activeView: 'categories',
    activeCategoryId: null,
    activeSectionId: null,
    history: [],
    selectedCategoryId: null,
    selectedSectionId: null,
    permissionCache: {},
};

// üéØ FUNCI√ìN HELPER PARA VALIDAR PERMISOS
// PORQU√â: Centraliza la l√≥gica de validaci√≥n de permisos
// CONEXI√ìN: Todas las operaciones CRUD ‚Üí esta funci√≥n ‚Üí validaci√≥n
const validatePermissionInternal = (permission: Permission): boolean => {
    // üß≠ MIGA DE PAN: Por ahora todos los permisos son true (admin)
    // FUTURO: Integrar con sistema de sesi√≥n real
    // CONEXI√ìN: usePermissions() hook ‚Üí esta l√≥gica ‚Üí validaciones UI
    return true; // TODO: Implementar validaci√≥n real con sesi√≥n
};

// --- CREACI√ìN DEL STORE ---

export const useDashboardStore = create<DashboardState & DashboardActions>((set, get) => ({
    ...initialState,

    // Funci√≥n simple que no causa loops
    validatePermission: () => {
        return true; // TODO: Implementar validaci√≥n real
    },

    clearPermissionCache: () => {
        set({ permissionCache: {} });
    },

    initializeDashboard: async (clientId) => {
        set({ isClientLoading: true, initialDataLoaded: false });
        try {
            const clientRes = await fetch(`/api/client?id=${clientId}`);
            if (!clientRes.ok) throw new Error('Cliente no encontrado');
            set({ client: await clientRes.json() });
            await get().fetchCategories(clientId);
        } catch (e) {
            set({ error: e instanceof Error ? e.message : 'Error' });
        } finally {
            set({ isClientLoading: false, initialDataLoaded: true });
        }
    },

    fetchCategories: async (clientId) => {
        set({ isLoading: true });
        try {
            const res = await fetch(`/api/categories?client_id=${clientId}`);
            if (!res.ok) throw new Error('Error al cargar categor√≠as');
            set({ categories: await res.json() });
        } catch (e) {
            set({ error: e instanceof Error ? e.message : 'Error' });
        } finally {
            set({ isLoading: false });
        }
    },

    fetchSectionsByCategory: async (categoryId) => {
        set({ isLoading: true });
        try {
            const res = await fetch(`/api/sections?category_id=${categoryId}`);
            if (!res.ok) throw new Error('Error al cargar secciones');
            const sectionsData = await res.json();
            set(state => ({ sections: { ...state.sections, [categoryId]: sectionsData } }));
        } catch (e) {
            set({ error: e instanceof Error ? e.message : 'Error' });
        } finally {
            set({ isLoading: false });
        }
    },

    fetchProductsBySection: async (sectionId) => {
        set({ isLoading: true });
        try {
            const res = await fetch(`/api/products?section_id=${sectionId}`);
            if (!res.ok) throw new Error('Error al cargar productos');
            const productsData = await res.json();
            set(state => ({ products: { ...state.products, [sectionId]: productsData } }));
        } catch (e) {
            set({ error: e instanceof Error ? e.message : 'Error' });
        } finally {
            set({ isLoading: false });
        }
    },

    fetchProductsByCategory: async (categoryId) => {
        // üß≠ MIGA DE PAN CONTEXTUAL: T31 - FUNCI√ìN CLAVE PARA PRODUCTOS H√çBRIDOS
        // PORQU√â MODIFICADA: Ahora carga productos H√çBRIDOS (tradicionales + directos) de una categor√≠a
        // PROBLEMA RESUELTO: Antes solo cargaba productos de categor√≠as "simples", ahora soporta T31
        // ARQUITECTURA: Usa API h√≠brida que combina productos de secciones + productos directos
        // CONEXIONES CR√çTICAS:
        // - /api/categories/[id]/products/route.ts: API modificada que obtiene productos h√≠bridos
        // - createProductDirect() l√≠nea 620: Recarga usando esta funci√≥n tras crear producto directo
        // - CategoryGridView.tsx: Renderizar√° productos directos + secciones usando esta data
        // - useCategoryProducts() l√≠nea 862: Hook que consume esta data para UI
        //
        // üéØ T31: FLUJO H√çBRIDO
        // 1. API consulta productos tradicionales (via secciones) + productos directos (via category_id)
        // 2. Elimina duplicados y ordena por display_order
        // 3. Retorna array unificado para mostrar en UI
        //
        // üí° Diferencia clave con fetchProductsBySection:
        // - fetchProductsBySection: usa section_id (jerarqu√≠a completa tradicional)
        // - fetchProductsByCategory: usa category_id (jerarqu√≠a h√≠brida T31)
        console.log('üéØ T31: Cargando productos h√≠bridos para categor√≠a:', categoryId);
        set({ isLoading: true });
        try {
            // T31: Usar API h√≠brida que obtiene productos tradicionales + directos
            // CONEXI√ìN: /api/categories/[id]/products/route.ts l√≠neas 15-45
            const res = await fetch(`/api/categories/${categoryId}/products`);
            if (!res.ok) throw new Error('Error al cargar productos h√≠bridos');
            const productsData = await res.json();
            
            console.log('üéØ T31: Productos h√≠bridos recibidos:', productsData.length, productsData);
            
            // T31: Key especial para productos h√≠bridos de categor√≠a (diferente de secciones)
            // PORQU√â: Permite distinguir productos de categor√≠a vs productos de secci√≥n en el store
            // CONEXI√ìN: useCategoryProducts() l√≠nea 862 usa esta key para acceder a los datos
            set(state => ({ products: { ...state.products, [`cat-${categoryId}`]: productsData } }));
            
            console.log('üéØ T31: Productos almacenados en store con key:', `cat-${categoryId}`);
        } catch (e) {
            console.error('üéØ T31: Error al cargar productos h√≠bridos:', e);
            set({ error: e instanceof Error ? e.message : 'Error' });
        } finally {
            set({ isLoading: false });
        }
    },

    fetchDataForCategory: async (categoryId) => {
        // üß≠ MIGA DE PAN: Esta es la funci√≥n MAESTRA de auto-detecci√≥n inteligente T31 (CORREGIDA)
        // PROBLEMA RESUELTO: Antes solo cargaba productos en modo "simple", ahora SIEMPRE carga h√≠bridos
        // PORQU√â CAMBIO: T31 requiere jerarqu√≠a h√≠brida - secciones Y productos directos simult√°neamente
        // 
        // üîç FLUJO T31 CORREGIDO:
        // 1. Carga las secciones de la categor√≠a (para mostrar en UI)
        // 2. Carga SIEMPRE los productos h√≠bridos (tradicionales + directos)
        // 3. La UI decide qu√© mostrar usando MixedContentView
        //
        // üéØ Se conecta con:
        // - DashboardViewWrapper.tsx ‚Üí MixedContentView para mostrar contenido h√≠brido
        // - useMixedContentForCategory() para filtrar y mostrar correctamente
        set({ isLoading: true });
        try {
            // Paso 1: Cargar secciones (siempre necesario para UI h√≠brida)
            await get().fetchSectionsByCategory(categoryId);
            
            // Paso 2: Cargar SIEMPRE productos h√≠bridos para T31
            // PORQU√â: Incluso categor√≠as con secciones pueden tener productos directos
            // CONEXI√ìN: MixedContentView necesita ambos tipos de datos para renderizar
            await get().fetchProductsByCategory(categoryId);
            
        } catch (e) {
            set({ error: e instanceof Error ? e.message : 'Error en carga h√≠brida T31' });
        } finally {
            set({ isLoading: false });
        }
    },

    // üéØ OPERACIONES CRUD CON VALIDACIONES

    createCategory: async (data, imageFile = null, skipPermissionCheck = false) => {
        // üîí VALIDACI√ìN DE PERMISOS
        // PORQU√â: Evita operaciones no autorizadas antes de enviar a servidor
        if (!skipPermissionCheck && !get().validatePermission('categories.create')) {
            toast.error('No tienes permisos para crear categor√≠as');
            return;
        }

        set({ isUpdating: true });
        try {
            const formData = new FormData();
            Object.entries(data).forEach(([key, value]) => {
                if (value !== null && value !== undefined) {
                    formData.append(key, value.toString());
                }
            });
            if (imageFile) formData.append('image', imageFile);

            const res = await fetch('/api/categories', {
                method: 'POST',
                body: formData,
            });

            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Error al crear categor√≠a');
            }

            const newCategory = await res.json();
            set(state => ({
                categories: [...state.categories, newCategory].sort((a, b) => (a.display_order || 0) - (b.display_order || 0))
            }));

            toast.success('Categor√≠a creada exitosamente');
        } catch (e) {
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    updateCategory: async (id, data, imageFile = null, skipPermissionCheck = false) => {
        // üîí VALIDACI√ìN DE PERMISOS
        if (!skipPermissionCheck && !get().validatePermission('categories.edit')) {
            toast.error('No tienes permisos para editar categor√≠as');
            return;
        }

        set({ isUpdating: true });
        
        // üéØ OPTIMISTIC UPDATE CON ROLLBACK
        // PORQU√â: UX inmediata con capacidad de revertir si falla
        const previousCategories = get().categories;
        const optimisticCategories = previousCategories.map(cat =>
            cat.category_id === id ? { ...cat, ...data } : cat
        );
        set({ categories: optimisticCategories });

        try {
            const formData = new FormData();
            Object.entries(data).forEach(([key, value]) => {
                if (value !== null && value !== undefined) {
                    formData.append(key, value.toString());
                }
            });
            if (imageFile) formData.append('image', imageFile);

            const res = await fetch(`/api/categories/${id}`, {
                method: 'PUT',
                body: formData,
            });

            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Error al actualizar categor√≠a');
            }

            const updatedCategory = await res.json();
            set(state => ({
                categories: state.categories.map(cat =>
                    cat.category_id === id ? updatedCategory : cat
                )
            }));

            toast.success('Categor√≠a actualizada exitosamente');
        } catch (e) {
            // üîÑ ROLLBACK EN CASO DE ERROR
            // PORQU√â: Restaura el estado anterior si la operaci√≥n falla
            set({ categories: previousCategories });
            
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    deleteCategory: async (id, skipPermissionCheck = false) => {
        // üîí VALIDACI√ìN DE PERMISOS
        if (!skipPermissionCheck && !get().validatePermission('categories.delete')) {
            toast.error('No tienes permisos para eliminar categor√≠as');
            return;
        }

        set({ isUpdating: true });
        
        // üéØ OPTIMISTIC UPDATE CON ROLLBACK COMPLETO
        // PORQU√â: Elimina de UI inmediatamente pero puede revertir
        const previousState = {
            categories: get().categories,
            sections: get().sections,
            products: get().products,
            selectedCategoryId: get().selectedCategoryId,
            selectedSectionId: get().selectedSectionId
        };

        // Eliminar categor√≠a y limpiar datos relacionados
        const updatedCategories = previousState.categories.filter(cat => cat.category_id !== id);
        const updatedSections = { ...previousState.sections };
        const updatedProducts = { ...previousState.products };
        delete updatedSections[id];
        delete updatedProducts[`cat-${id}`];

        // Reset de selecci√≥n si se elimina la categor√≠a activa
        const newSelectedCategoryId = previousState.selectedCategoryId === id ? null : previousState.selectedCategoryId;
        const newSelectedSectionId = previousState.selectedCategoryId === id ? null : previousState.selectedSectionId;

        set({
            categories: updatedCategories,
            sections: updatedSections,
            products: updatedProducts,
            selectedCategoryId: newSelectedCategoryId,
            selectedSectionId: newSelectedSectionId
        });

        try {
            const res = await fetch(`/api/categories/${id}`, {
                method: 'DELETE',
            });

            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Error al eliminar categor√≠a');
            }

            toast.success('Categor√≠a eliminada exitosamente');
        } catch (e) {
            // üîÑ ROLLBACK COMPLETO
            // PORQU√â: Restaura todo el estado anterior incluyendo selecciones
            set(previousState);
            
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    toggleCategoryVisibility: async (id, status, skipPermissionCheck = false) => {
        // üîí VALIDACI√ìN DE PERMISOS
        if (!skipPermissionCheck && !get().validatePermission('categories.visibility')) {
            toast.error('No tienes permisos para cambiar la visibilidad');
            return;
        }

        await get().updateCategory(id, { status: status === 1 }, null, true);
    },

    // üéØ OPERACIONES DE SECCIONES CON VALIDACIONES
    // PORQU√â: Misma l√≥gica de validaciones aplicada a secciones

    createSection: async (data, imageFile = null, skipPermissionCheck = false) => {
        if (!skipPermissionCheck && !get().validatePermission('sections.create')) {
            toast.error('No tienes permisos para crear secciones');
            return;
        }

        set({ isUpdating: true });
        try {
            const formData = new FormData();
            Object.entries(data).forEach(([key, value]) => {
                if (value !== null && value !== undefined) {
                    formData.append(key, value.toString());
                }
            });
            if (imageFile) formData.append('image', imageFile);

            const res = await fetch('/api/sections', {
                method: 'POST',
                body: formData,
            });

            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Error al crear secci√≥n');
            }

            const newSection = await res.json();
            const categoryId = newSection.category_id;
            
            set(state => ({
                sections: {
                    ...state.sections,
                    [categoryId]: [...(state.sections[categoryId] || []), newSection]
                        .sort((a, b) => (a.display_order || 0) - (b.display_order || 0))
                }
            }));

            toast.success('Secci√≥n creada exitosamente');
        } catch (e) {
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    updateSection: async (id, data, imageFile = null, skipPermissionCheck = false) => {
        if (!skipPermissionCheck && !get().validatePermission('sections.edit')) {
            toast.error('No tienes permisos para editar secciones');
            return;
        }

        set({ isUpdating: true });
        
        // Optimistic update con rollback
        const previousSections = get().sections;
        let targetCategoryId: number | null = null;
        
        const optimisticSections = { ...previousSections };
        for (const [categoryId, sections] of Object.entries(previousSections)) {
            const sectionIndex = sections.findIndex(s => s.section_id === id);
            if (sectionIndex !== -1) {
                targetCategoryId = parseInt(categoryId);
                optimisticSections[categoryId] = sections.map(section =>
                    section.section_id === id ? { ...section, ...data } : section
                );
                break;
            }
        }
        
        set({ sections: optimisticSections });

        try {
            const formData = new FormData();
            Object.entries(data).forEach(([key, value]) => {
                if (value !== null && value !== undefined) {
                    formData.append(key, value.toString());
                }
            });
            if (imageFile) formData.append('image', imageFile);

            const res = await fetch(`/api/sections/${id}`, {
                method: 'PUT',
                body: formData,
            });

            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Error al actualizar secci√≥n');
            }

            const updatedSection = await res.json();
            const categoryId = updatedSection.category_id;
            
            set(state => ({
                sections: {
                    ...state.sections,
                    [categoryId]: state.sections[categoryId]?.map(section =>
                        section.section_id === id ? updatedSection : section
                    ) || []
                }
            }));

            toast.success('Secci√≥n actualizada exitosamente');
        } catch (e) {
            // Rollback
            set({ sections: previousSections });
            
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    deleteSection: async (id, skipPermissionCheck = false) => {
        if (!skipPermissionCheck && !get().validatePermission('sections.delete')) {
            toast.error('No tienes permisos para eliminar secciones');
            return;
        }

        set({ isUpdating: true });
        
        // Optimistic update con rollback completo
        const previousState = {
            sections: get().sections,
            products: get().products,
            selectedSectionId: get().selectedSectionId
        };

        // Encontrar y eliminar la secci√≥n
        const updatedSections = { ...previousState.sections };
        let targetCategoryId: number | null = null;
        
        for (const [categoryId, sections] of Object.entries(updatedSections)) {
            const sectionIndex = sections.findIndex(s => s.section_id === id);
            if (sectionIndex !== -1) {
                targetCategoryId = parseInt(categoryId);
                updatedSections[categoryId] = sections.filter(s => s.section_id !== id);
                break;
            }
        }

        // Limpiar productos de la secci√≥n eliminada
        const updatedProducts = { ...previousState.products };
        delete updatedProducts[id];

        // Reset selecci√≥n si se elimina la secci√≥n activa
        const newSelectedSectionId = previousState.selectedSectionId === id ? null : previousState.selectedSectionId;

        set({
            sections: updatedSections,
            products: updatedProducts,
            selectedSectionId: newSelectedSectionId
        });

        try {
            const res = await fetch(`/api/sections/${id}`, {
                method: 'DELETE',
            });

            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Error al eliminar secci√≥n');
            }

            toast.success('Secci√≥n eliminada exitosamente');
        } catch (e) {
            // Rollback completo
            set(previousState);
            
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    toggleSectionVisibility: async (id, status, skipPermissionCheck = false) => {
        if (!skipPermissionCheck && !get().validatePermission('sections.visibility')) {
            toast.error('No tienes permisos para cambiar la visibilidad');
            return;
        }

        await get().updateSection(id, { status: status === 1 }, null, true);
    },

    // üéØ OPERACIONES DE PRODUCTOS CON VALIDACIONES
    // PORQU√â: Validaciones de permisos aplicadas a todas las operaciones de productos

    createProduct: async (data, imageFile = null, skipPermissionCheck = false) => {
        if (!skipPermissionCheck && !get().validatePermission('products.create')) {
            toast.error('No tienes permisos para crear productos');
            return;
        }

        set({ isUpdating: true });
        try {
            const formData = new FormData();
            Object.entries(data).forEach(([key, value]) => {
                if (value !== null && value !== undefined) {
                    formData.append(key, value.toString());
                }
            });
            if (imageFile) formData.append('image', imageFile);

            const res = await fetch('/api/products', {
                method: 'POST',
                body: formData,
            });

            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Error al crear producto');
            }

            const newProduct = await res.json();
            const sectionId = newProduct.section_id;
            
            if (sectionId) {
                set(state => ({
                    products: {
                        ...state.products,
                        [sectionId]: [...(state.products[sectionId] || []), newProduct]
                            .sort((a, b) => (a.display_order || 0) - (b.display_order || 0))
                    }
                }));
            }

            toast.success('Producto creado exitosamente');
        } catch (e) {
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    createProductDirect: async (categoryId, data, imageFile = null, skipPermissionCheck = false) => {
        // üéØ T31: CREAR PRODUCTO DIRECTO EN CATEGOR√çA
        // PORQU√â: Permite crear productos sin secci√≥n intermedia
        // VALIDACI√ìN: Misma l√≥gica de permisos que createProduct
        console.log('üéØ T31: Iniciando creaci√≥n de producto directo:', { categoryId, data });
        
        if (!skipPermissionCheck && !get().validatePermission('products.create')) {
            toast.error('No tienes permisos para crear productos');
            return;
        }

        set({ isUpdating: true });
        try {
            const productData = { ...data, category_id: categoryId, section_id: null };
            console.log('üéØ T31: Datos del producto a enviar:', productData);
            
            const formData = new FormData();
            
            Object.entries(productData).forEach(([key, value]) => {
                if (value !== null && value !== undefined) {
                    formData.append(key, value.toString());
                }
            });
            if (imageFile) formData.append('image', imageFile);

            console.log('üéØ T31: Enviando request a /api/products...');
            const res = await fetch('/api/products', {
                method: 'POST',
                body: formData,
            });

            if (!res.ok) {
                const errorData = await res.json();
                console.error('üéØ T31: Error en respuesta API:', errorData);
                throw new Error(errorData.error || 'Error al crear producto directo');
            }

            const newProduct = await res.json();
            console.log('üéØ T31: Producto creado exitosamente:', newProduct);

            // Recargar productos h√≠bridos de la categor√≠a
            console.log('üéØ T31: Recargando productos de categor√≠a:', categoryId);
            await get().fetchProductsByCategory(categoryId);

            toast.success('Producto creado exitosamente en categor√≠a');
        } catch (e) {
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            console.error('üéØ T31: Error completo:', e);
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    updateProduct: async (id, data, imageFile = null, skipPermissionCheck = false) => {
        if (!skipPermissionCheck && !get().validatePermission('products.edit')) {
            toast.error('No tienes permisos para editar productos');
            return;
        }

        set({ isUpdating: true });
        
        // Optimistic update con rollback
        const previousProducts = get().products;
        let targetKey: string | null = null;
        
        const optimisticProducts = { ...previousProducts };
        for (const [key, products] of Object.entries(previousProducts)) {
            const productIndex = products.findIndex(p => p.product_id === id);
            if (productIndex !== -1) {
                targetKey = key;
                optimisticProducts[key] = products.map(product =>
                    product.product_id === id ? { ...product, ...data } : product
                );
                break;
            }
        }
        
        set({ products: optimisticProducts });

        try {
            const formData = new FormData();
            Object.entries(data).forEach(([key, value]) => {
                if (value !== null && value !== undefined) {
                    formData.append(key, value.toString());
                }
            });
            if (imageFile) formData.append('image', imageFile);

            const res = await fetch(`/api/products/${id}`, {
                method: 'PUT',
                body: formData,
            });

            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Error al actualizar producto');
            }

            const updatedProduct = await res.json();
            
            // Determinar la key correcta para actualizar
            const newSectionId = updatedProduct.section_id;
            const newCategoryId = updatedProduct.category_id;
            const newKey = newSectionId ? newSectionId.toString() : `cat-${newCategoryId}`;
            
            // Si cambi√≥ de ubicaci√≥n, recargar ambas ubicaciones
            if (targetKey && targetKey !== newKey) {
                // Recargar ubicaci√≥n anterior y nueva
                if (targetKey.startsWith('cat-')) {
                    const oldCategoryId = parseInt(targetKey.replace('cat-', ''));
                    await get().fetchProductsByCategory(oldCategoryId);
                } else {
                    await get().fetchProductsBySection(parseInt(targetKey));
                }
                
                if (newKey.startsWith('cat-')) {
                    await get().fetchProductsByCategory(newCategoryId);
                } else {
                    await get().fetchProductsBySection(newSectionId);
                }
            } else {
                // Actualizaci√≥n en la misma ubicaci√≥n
                set(state => ({
                    products: {
                        ...state.products,
                        [newKey]: state.products[newKey]?.map(product =>
                            product.product_id === id ? updatedProduct : product
                        ) || []
                    }
                }));
            }

            toast.success('Producto actualizado exitosamente');
        } catch (e) {
            // Rollback
            set({ products: previousProducts });
            
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    deleteProduct: async (id, skipPermissionCheck = false) => {
        if (!skipPermissionCheck && !get().validatePermission('products.delete')) {
            toast.error('No tienes permisos para eliminar productos');
            return;
        }

        set({ isUpdating: true });
        
        // Optimistic update con rollback
        const previousProducts = get().products;
        let targetKey: string | null = null;
        
        const updatedProducts = { ...previousProducts };
        for (const [key, products] of Object.entries(updatedProducts)) {
            const productIndex = products.findIndex(p => p.product_id === id);
            if (productIndex !== -1) {
                targetKey = key;
                updatedProducts[key] = products.filter(p => p.product_id !== id);
                break;
            }
        }
        
        set({ products: updatedProducts });

        try {
            const res = await fetch(`/api/products/${id}`, {
                method: 'DELETE',
            });

            if (!res.ok) {
                const errorData = await res.json();
                throw new Error(errorData.error || 'Error al eliminar producto');
            }

            toast.success('Producto eliminado exitosamente');
        } catch (e) {
            // Rollback
            set({ products: previousProducts });
            
            const errorMessage = e instanceof Error ? e.message : 'Error desconocido';
            set({ error: errorMessage });
            toast.error(errorMessage);
            throw e;
        } finally {
            set({ isUpdating: false });
        }
    },

    toggleProductVisibility: async (id, status, skipPermissionCheck = false) => {
        if (!skipPermissionCheck && !get().validatePermission('products.visibility')) {
            toast.error('No tienes permisos para cambiar la visibilidad');
            return;
        }

        await get().updateProduct(id, { status: status === 1 }, null, true);
    },

    // üéØ FUNCIONES DE NAVEGACI√ìN (sin cambios)
    setSelectedCategoryId: (id) => set({ selectedCategoryId: id }),
    setSelectedSectionId: (id) => set({ selectedSectionId: id }),

    handleCategorySelect: (id) => {
        // üß≠ MIGA DE PAN: Funci√≥n de navegaci√≥n inteligente para m√≥vil
        // PORQU√â: Maneja la navegaci√≥n entre vistas en m√≥vil con historial
        // CONEXI√ìN: MobileView.tsx ‚Üí esta funci√≥n ‚Üí cambio de vista
        // FLUJO: categories ‚Üí sections (si hay) ‚Üí products
        set(state => ({
            activeCategoryId: id,
            activeView: 'sections',
            history: [...state.history, { view: 'categories', id: null }]
        }));
    },

    handleSectionSelect: (id) => {
        // üß≠ MIGA DE PAN: Navegaci√≥n a productos desde secci√≥n
        // PORQU√â: Cambia a vista de productos y carga los datos
        // CONEXI√ìN: SectionGridView ‚Üí esta funci√≥n ‚Üí ProductGridView
        set(state => ({
            activeSectionId: id,
            activeView: 'products',
            history: [...state.history, { view: 'sections', id: state.activeCategoryId }]
        }));
    },

    handleBack: () => {
        // üß≠ MIGA DE PAN: Navegaci√≥n hacia atr√°s con historial
        // PORQU√â: Permite volver a la vista anterior manteniendo el contexto
        // CONEXI√ìN: Bot√≥n back ‚Üí esta funci√≥n ‚Üí vista anterior
        set(state => {
            const newHistory = [...state.history];
            const previousView = newHistory.pop();
            
            if (!previousView) {
                return { activeView: 'categories', activeCategoryId: null, activeSectionId: null };
            }
            
            return {
                activeView: previousView.view,
                activeCategoryId: previousView.view === 'categories' ? null : state.activeCategoryId,
                activeSectionId: previousView.view === 'sections' ? null : state.activeSectionId,
                history: newHistory
            };
        });
    },
}));

// --- HOOKS DERIVADOS CORREGIDOS ---

export const useCategoryDisplayMode = (categoryId: number | null) => {
    return useDashboardStore(
        (state) => {
            if (!categoryId) return 'sections';
            const sections = state.sections[categoryId] || [];
            return getCategoryDisplayMode(sections);
        },
        // Funci√≥n de igualdad simple para strings
        (a, b) => a === b
    );
};

export const useCategoryProducts = (categoryId: number | null, sectionId?: number | null) => {
    return useDashboardStore(
        (state) => {
            if (sectionId) {
                return state.products[sectionId] || [];
            } else if (categoryId) {
                return state.products[`cat-${categoryId}`] || [];
            }
            return [];
        },
        // Comparaci√≥n superficial de arrays
        (a, b) => {
            if (a.length !== b.length) return false;
            return a.every((item, index) => item.product_id === b[index]?.product_id);
        }
    );
};

// üö® HOOK SIMPLIFICADO PARA EVITAR BUCLES INFINITOS
export const useCategoryWithCounts = (categoryId: number | null) => {
    // Enfoque ultra-simple: solo obtener datos b√°sicos sin c√°lculos complejos
    const categories = useDashboardStore(state => state.categories);
    const sections = useDashboardStore(state => state.sections);
    const products = useDashboardStore(state => state.products);
    
    // Usar useMemo para cachear el resultado y evitar rec√°lculos
    return React.useMemo(() => {
        if (!categoryId) return null;
        
        const category = categories.find(c => c.category_id === categoryId);
        if (!category) return null;
        
        const categorySections = sections[categoryId] || [];
        const categoryProducts = products[`cat-${categoryId}`] || [];
        
        return {
            category_id: category.category_id,
            name: category.name,
            status: category.status,
            image: category.image,
            display_order: category.display_order,
            client_id: category.client_id,
            sectionsCount: categorySections.length,
            visibleSectionsCount: categorySections.filter(s => s.status).length,
            productsCount: categoryProducts.length,
            visibleProductsCount: categoryProducts.filter(p => p.status).length,
        };
    }, [categoryId, categories, sections, products]);
};

// üß≠ MIGA DE PAN CONTEXTUAL: Selector para Lista Mixta T31 (FASE 1.2) - CORREGIDO BUCLE INFINITO
// PORQU√â CR√çTICO: Implementa la jerarqu√≠a h√≠brida mostrando secciones y productos directos juntos
// PROBLEMA RESUELTO: Sin este selector, no podemos renderizar contenido mixto en una sola vista
// CONEXI√ìN: DashboardViewWrapper ‚Üí useMixedContentForCategory ‚Üí MixedContentView
// PATR√ìN v0.dev: Selector memoizado que combina diferentes tipos de datos con discriminated union
// üö® CORRECCI√ìN: Eliminada funci√≥n de comparaci√≥n compleja que causaba bucles infinitos
export const useMixedContentForCategory = (categoryId: number | null) => {
    const sections = useDashboardStore(state => state.sections);
    const products = useDashboardStore(state => state.products);
    
    // üß≠ MIGA DE PAN: useMemo para evitar rec√°lculos y bucles infinitos
    // PORQU√â: React.useMemo es m√°s estable que selector personalizado de Zustand
    // PROBLEMA RESUELTO: Funci√≥n de comparaci√≥n compleja causaba re-renders infinitos
    return React.useMemo(() => {
        if (!categoryId) return [];
        
        // Obtener secciones de la categor√≠a
        const categorySections = (sections[categoryId] || [])
            .map(section => ({ ...section, itemType: 'section' as const }))
            .sort((a, b) => (a.display_order || 0) - (b.display_order || 0));
        
        // Obtener productos directos de la categor√≠a (SOLO los que tienen category_id y NO section_id)
        // üß≠ MIGA DE PAN: FILTRO CR√çTICO - Solo productos directos, no tradicionales
        // PROBLEMA RESUELTO: API devuelve todos los productos, pero UI debe mostrar solo directos
        // CONEXI√ìN: products[cat-X] contiene h√≠bridos, pero MixedContentView necesita solo directos
        // Obtener productos directos de la categor√≠a (SOLO los que tienen category_id y NO section_id)
        // üß≠ MIGA DE PAN: FILTRO CR√çTICO - Solo productos directos, no tradicionales
        // PROBLEMA RESUELTO: API devuelve todos los productos, pero UI debe mostrar solo directos
        // CONEXI√ìN: products[cat-X] contiene h√≠bridos, pero MixedContentView necesita solo directos
        const directProducts = (products[`cat-${categoryId}`] || [])
            .filter(product => product.category_id === categoryId && product.section_id === null)
            .map(product => ({ ...product, itemType: 'product' as const }))
            .sort((a, b) => (a.display_order || 0) - (b.display_order || 0));
        
        // üß≠ MIGA DE PAN: Ordenamiento estrat√©gico - secciones primero, productos despu√©s
        // PORQU√â: UX m√°s intuitiva - estructura jer√°rquica antes que elementos directos
        // PATR√ìN v0.dev: Spread operator para combinar arrays manteniendo inmutabilidad
        return [...categorySections, ...directProducts];
    }, [categoryId, sections, products]);
};
