"use client";

import { useState, useEffect, Fragment, useRef } from 'react';
import { EyeIcon, PlusIcon, ChevronDownIcon, PencilIcon, XMarkIcon, TrashIcon, ArrowUpTrayIcon, DevicePhoneMobileIcon } from '@heroicons/react/24/outline';
import Link from 'next/link';
import Image from 'next/image';
import { useSession } from 'next-auth/react';
import { PhonePreview } from '@/components/PhonePreview';
import FloatingPhonePreview from '@/components/FloatingPhonePreview';
import { DragDropContext, Droppable, Draggable } from '@hello-pangea/dnd';
import { Dialog, Transition, Disclosure } from '@headlessui/react';
import { toast } from 'react-hot-toast';
import { getImagePath, handleImageError } from '@/lib/imageUtils';
import MenuSectionProducts from '@/components/MenuSectionProducts';
import ContentPanel from '@/components/ContentPanel';
import CollapsiblePreview from '@/components/CollapsiblePreview';
import CategoryTable from '@/components/CategoryTable';
import SectionTable from '@/components/SectionTable';
import ProductTable from '@/components/ProductTable';
import Breadcrumbs from '@/components/Breadcrumbs';
import TopNavbar from '@/components/layout/TopNavbar';
import useSections from '@/app/hooks/useSections';
import useProducts from '@/app/hooks/useProducts';
// Importar los componentes de modal que hemos creado
import { NewCategoryModal, DeleteSectionModal, DeleteProductModal } from './dashboardModals';
// Importar los tipos desde el archivo centralizado
import { Category, Section, Product, Client } from '@/app/types/menu';
import EditProductModal from './components/EditProductModal';
import NewCategoryModalComponent from './components/NewCategoryModal';
import EditSectionModal from './components/EditSectionModal';
import NewSectionModal from './components/NewSectionModal';
import NewProductModal from './components/NewProductModal';

// Interfaces para FloatingPhonePreview
interface FloatingPhoneCategory {
  id: number;
  category_id?: number;
  name: string;
  image?: string;
  sections?: FloatingPhoneSection[];
}

interface FloatingPhoneSection {
  id: number;
  name: string;
  image?: string;
  products?: FloatingPhoneProduct[];
}

interface FloatingPhoneProduct {
  id: number;
  name: string;
  price: string | number;
  description?: string;
  image?: string;
}

// Extender la interfaz Client para incluir la propiedad id
interface DashboardClient extends Client {
  id: number;
  logo?: string | null;
  name: string;
  main_logo: string | null;
}

// ----- FUNCIONES DE API -----

/**
 * Obtiene datos del cliente autenticado
 * 
 * @returns Promise con los datos del cliente
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function fetchClientData() {
  const response = await fetch('/api/client');
  if (!response.ok) throw new Error('Error al cargar datos del cliente');
  return await response.json();
}

/**
 * Obtiene las categorías del cliente autenticado
 * 
 * @returns Promise con las categorías
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function fetchCategories() {
  const response = await fetch('/api/categories');
  if (!response.ok) throw new Error('Error al cargar categorías');
  return await response.json();
}

/**
 * Obtiene las secciones para una categoría específica
 * 
 * @param categoryId - ID de la categoría
 * @returns Promise con las secciones
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function fetchSections(categoryId: number) {
  const response = await fetch(`/api/sections?category_id=${categoryId}`);
  if (!response.ok) throw new Error('Error al cargar secciones');
  return await response.json();
}

/**
 * Obtiene los productos para una sección específica
 * 
 * @param sectionId - ID de la sección
 * @returns Promise con los productos
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function fetchProducts(sectionId: number) {
  const response = await fetch(`/api/products?section_id=${sectionId}`);
  if (!response.ok) throw new Error('Error al cargar productos');
  return await response.json();
}

// ----- FUNCIONES DE API PARA CATEGORÍAS -----

/**
 * Actualiza el orden de una categoría
 * 
 * @param categoryId - ID de la categoría
 * @param newDisplayOrder - Nuevo orden de visualización
 * @returns Promise con la categoría actualizada
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function updateCategoryOrder(categoryId: number, newDisplayOrder: number) {
  try {
    const response = await fetch(`/api/categories/${categoryId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ display_order: newDisplayOrder }),
    });
    
    if (!response.ok) {
      throw new Error('Error al actualizar el orden');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error al actualizar el orden de la categoría:', error);
    throw error;
  }
}

/**
 * Actualiza la visibilidad de una categoría
 * 
 * @param categoryId - ID de la categoría
 * @param newStatus - Nuevo estado de visibilidad (0 o 1)
 * @returns Promise con la categoría actualizada
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function updateCategoryVisibility(categoryId: number, newStatus: number) {
  try {
    console.log(`DEBUG: Actualizando visibilidad de categoría ${categoryId} a ${newStatus}`);
    
    // Cambiar para usar el endpoint principal con método PUT en lugar de la URL con ID
    const response = await fetch('/api/categories', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        category_id: categoryId,
        status: newStatus
      }),
    });
    
    console.log('DEBUG: Respuesta recibida, status:', response.status);
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('DEBUG: Error en respuesta:', errorData);
      throw new Error('Error al actualizar la visibilidad');
    }
    
    const data = await response.json();
    console.log('DEBUG: Datos recibidos:', data);
    return data;
  } catch (error) {
    console.error('Error al actualizar la visibilidad de la categoría:', error);
    throw error;
  }
}

/**
 * Elimina una categoría
 * 
 * @param categoryId - ID de la categoría a eliminar
 * @returns Promise con la respuesta de la API
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function deleteCategory(categoryId: number) {
  try {
    const response = await fetch(`/api/categories/${categoryId}`, {
      method: 'DELETE',
    });
    
    if (!response.ok) {
      throw new Error('Error al eliminar la categoría');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error al eliminar la categoría:', error);
    throw error;
  }
}

// ----- OTRAS FUNCIONES DE API -----

/**
 * Crea un nuevo cliente
 * 
 * @param clientData - Datos del cliente en formato FormData
 * @returns Promise con el cliente creado
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function createClient(clientData: FormData) {
  const response = await fetch('/api/client', {
    method: 'POST',
    body: clientData
  });
  if (!response.ok) throw new Error('Error al crear cliente');
  return await response.json();
}

// ----- FUNCIONES DE API PARA SECCIONES -----

/**
 * Actualiza la visibilidad de una sección
 * 
 * @param sectionId - ID de la sección
 * @param newStatus - Nuevo estado de visibilidad (0 o 1)
 * @returns Promise con la sección actualizada
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function updateSectionVisibility(sectionId: number, newStatus: number) {
  try {
    console.log(`DEBUG: Actualizando visibilidad de sección ${sectionId} a ${newStatus}`);
    
    const response = await fetch('/api/sections', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        section_id: sectionId,
        status: newStatus
      }),
    });
    
    console.log('DEBUG: Respuesta recibida, status:', response.status);
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('DEBUG: Error en respuesta:', errorData);
      throw new Error('Error al actualizar la visibilidad');
    }
    
    const data = await response.json();
    console.log('DEBUG: Datos recibidos:', data);
    return data;
  } catch (error) {
    console.error('Error al actualizar la visibilidad de la sección:', error);
    throw error;
  }
}

// ----- FUNCIONES DE API PARA PRODUCTOS -----

/**
 * Actualiza la visibilidad de un producto
 * 
 * @param productId - ID del producto
 * @param newStatus - Nuevo estado de visibilidad (0 o 1)
 * @returns Promise con el producto actualizado
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
async function updateProductVisibility(productId: number, newStatus: number) {
  try {
    console.log(`DEBUG: Actualizando visibilidad de producto ${productId} a ${newStatus}`);
    
    const response = await fetch('/api/products', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        product_id: productId,
        status: newStatus
      }),
    });
    
    console.log('DEBUG: Respuesta recibida, status:', response.status);
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('DEBUG: Error en respuesta:', errorData);
      throw new Error('Error al actualizar la visibilidad');
    }
    
    const data = await response.json();
    console.log('DEBUG: Datos recibidos:', data);
    return data;
  } catch (error) {
    console.error('Error al actualizar la visibilidad del producto:', error);
    throw error;
  }
}

// ... [resto de funciones API existentes]

// ----- COMPONENTE PRINCIPAL -----

/**
 * Página principal del dashboard
 * Gestiona la visualización y edición de categorías, secciones y productos
 * 
 * Actualizado: 23-03-2025 (UTC+0 - Londres)
 */
export default function DashboardPage() {
  const { data: session, status } = useSession();
  const [isLoading, setIsLoading] = useState(true);
  const [client, setClient] = useState<DashboardClient | null>(null);
  const [categories, setCategories] = useState<Category[]>([]);
  const [sections, setSections] = useState<Record<string, Section[]>>({});
  const [products, setProducts] = useState<Record<string, Product[]>>({});
  const [expandedCategories, setExpandedCategories] = useState<Record<number, boolean>>({});
  const [expandedSections, setExpandedSections] = useState<Record<number, boolean>>({});
  const [loadingSections, setLoadingSections] = useState<Record<number, boolean>>({});
  const [loadingProducts, setLoadingProducts] = useState<Record<number, boolean>>({});
  const [error, setError] = useState<string | null>(null);
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(null);
  const [isUpdatingOrder, setIsUpdatingOrder] = useState(false);
  const [isUpdatingVisibility, setIsUpdatingVisibility] = useState<number | null>(null);
  const [editingCategory, setEditingCategory] = useState<{ id: number, name: string } | null>(null);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isDeletingCategory, setIsDeletingCategory] = useState(false);
  const [categoryToDelete, setCategoryToDelete] = useState<number | null>(null);
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  const [isNewCategoryModalOpen, setIsNewCategoryModalOpen] = useState(false);
  const [isUpdatingName, setIsUpdatingName] = useState(false);
  const [selectedCategoryId, setSelectedCategoryId] = useState<number | null>(null);
  const [editCategoryName, setEditCategoryName] = useState('');
  const [editCategoryImage, setEditCategoryImage] = useState<File | null>(null);
  const [editImagePreview, setEditImagePreview] = useState<string | null>(null);
  const [expandedImage, setExpandedImage] = useState<string | null>(null);
  const [currentView, setCurrentView] = useState<'categories' | 'sections' | 'products'>('categories');
  const [selectedSection, setSelectedSection] = useState<Section | null>(null);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [selectedSections, setSelectedSections] = useState<string[]>([]);
  const [isEditProductModalOpen, setIsEditProductModalOpen] = useState(false);
  const [isDeleteProductModalOpen, setIsDeleteProductModalOpen] = useState(false);
  const [isReorderModeActive, setIsReorderModeActive] = useState(false);
  const [isNewSectionModalOpen, setIsNewSectionModalOpen] = useState(false);
  const [isCreatingProduct, setIsCreatingProduct] = useState(false);
  const [isDeleteSectionModalOpen, setIsDeleteSectionModalOpen] = useState(false);
  const [sectionToDelete, setSectionToDelete] = useState<number | null>(null);
  const [isDeletingSection, setIsDeletingSection] = useState(false);
  const [productToDelete, setProductToDelete] = useState<number | null>(null);
  const [isDeletingProduct, setIsDeletingProduct] = useState(false);
  
  // Estados para edición de sección
  const [isEditSectionModalOpen, setIsEditSectionModalOpen] = useState(false);
  const [editingSection, setEditingSection] = useState<{ id: number; name: string } | null>(null);
  
  // Estados para edición de producto
  const [editingProduct, setEditingProduct] = useState<{ id: number; name: string } | null>(null);
  
  // Referencias para el scroll automático
  const sectionListRef = useRef<HTMLDivElement>(null);
  const productListRef = useRef<HTMLDivElement>(null);

  // ----- MANEJADORES DE EVENTOS -----
  
  // Función para reordenar categorías (drag and drop)
  const handleReorderCategory = async (sourceIndex: number, destinationIndex: number) => {
    if (sourceIndex === destinationIndex) return;
    
    try {
      setIsLoading(true);
      
      // Crear una copia del array de categorías
      const updatedCategories = [...categories];
      
      // Obtener la categoría que se está moviendo
      const [movedCategory] = updatedCategories.splice(sourceIndex, 1);
      
      // Insertar la categoría en la nueva posición
      updatedCategories.splice(destinationIndex, 0, movedCategory);
      
      // Actualizar los display_order de todas las categorías reordenadas
      const reorderedCategories = updatedCategories.map((category, index) => ({
        ...category,
        display_order: index + 1,
      }));
      
      // Actualizar el estado local inmediatamente para mejor UX
      setCategories(reorderedCategories);
      
      // Enviar los cambios al servidor
      const updatePromises = reorderedCategories.map(category => 
        fetch(`/api/categories/${category.category_id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            display_order: category.display_order,
            // Incluir otros campos necesarios para la API
            name: category.name,
            client_id: category.client_id,
            image: category.image || null,
            status: category.status
          }),
        })
      );
      
      await Promise.all(updatePromises);
      toast.success('Orden de categorías actualizado');
    } catch (error) {
      console.error('Error al reordenar categorías:', error);
      toast.error('Error al actualizar el orden de las categorías');
      
      // Volver a cargar las categorías en caso de error
      const loadCategories = async () => {
        try {
        const categoriesData = await fetchCategories();
        setCategories(categoriesData);
        } catch (err) {
          console.error('Error al recargar categorías:', err);
        }
      };
      
      loadCategories();
      } finally {
        setIsLoading(false);
      }
    };
    
  // Función para reordenar secciones (drag and drop)
  const handleReorderSection = async (sourceIndex: number, destinationIndex: number) => {
    if (sourceIndex === destinationIndex || !selectedCategory) return;
    
    try {
      setIsLoading(true);
      
      // Crear una copia del array de secciones
      const currentSections = sections[selectedCategory.category_id] || [];
      const updatedSections = [...currentSections];
      
      // Obtener la sección que se está moviendo
      const [movedSection] = updatedSections.splice(sourceIndex, 1);
      
      // Insertar la sección en la nueva posición
      updatedSections.splice(destinationIndex, 0, movedSection);
      
      // Actualizar los display_order de todas las secciones reordenadas
      const reorderedSections = updatedSections.map((section, index) => ({
        ...section,
        display_order: index + 1,
      }));
      
      // Actualizar el estado local inmediatamente para mejor UX
      setSections(prev => ({
        ...prev,
        [selectedCategory.category_id]: reorderedSections
      }));
      
      // Enviar los cambios al servidor
      const updatePromises = reorderedSections.map(section => 
        fetch(`/api/sections/${section.section_id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            display_order: section.display_order,
            // Incluir otros campos necesarios para la API
            name: section.name,
            category_id: section.category_id,
            client_id: section.client_id,
            image: section.image || null,
            status: section.status
          }),
        })
      );
      
      await Promise.all(updatePromises);
      toast.success('Orden de secciones actualizado');
    } catch (error) {
      console.error('Error al reordenar secciones:', error);
      toast.error('Error al actualizar el orden de las secciones');
      
      // Volver a cargar las secciones en caso de error
      if (selectedCategory) {
        const loadSections = async (categoryId: number) => {
          try {
            const sectionsData = await fetchSections(categoryId);
            setSections(prev => ({
              ...prev,
              [categoryId]: sectionsData
            }));
          } catch (err) {
            console.error('Error al recargar secciones:', err);
          }
        };
        
        loadSections(selectedCategory.category_id);
      }
    } finally {
      setIsLoading(false);
    }
  };

  // Función para reordenar productos (drag and drop)
  const handleReorderProduct = async (sourceIndex: number, destinationIndex: number) => {
    if (sourceIndex === destinationIndex || !selectedSection) return;
    
    try {
      setIsLoading(true);
      
      // Crear una copia del array de productos
      const currentProducts = products[selectedSection.section_id] || [];
      const updatedProducts = [...currentProducts];
      
      // Obtener el producto que se está moviendo
      const [movedProduct] = updatedProducts.splice(sourceIndex, 1);
      
      // Insertar el producto en la nueva posición
      updatedProducts.splice(destinationIndex, 0, movedProduct);
      
      // Actualizar los display_order de todos los productos reordenados
      const reorderedProducts = updatedProducts.map((product, index) => ({
        ...product,
        display_order: index + 1,
      }));
      
      // Actualizar el estado local inmediatamente para mejor UX
      setProducts(prev => ({
        ...prev,
        [selectedSection.section_id]: reorderedProducts
      }));
      
      // Enviar los cambios al servidor
      const updatePromises = reorderedProducts.map(product => 
        fetch(`/api/products/${product.product_id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            display_order: product.display_order,
            // Incluir otros campos necesarios para la API
            name: product.name,
            section_id: selectedSection.section_id,
            client_id: product.client_id,
            image: product.image || null,
            status: product.status,
            price: product.price,
            description: product.description || null
          }),
        })
      );
      
      await Promise.all(updatePromises);
      toast.success('Orden de productos actualizado');
    } catch (error) {
      console.error('Error al reordenar productos:', error);
      toast.error('Error al actualizar el orden de los productos');
      
      // Volver a cargar los productos en caso de error
      if (selectedSection) {
        const loadProducts = async (sectionId: number) => {
          try {
            const productsData = await fetchProducts(sectionId);
            setProducts(prev => ({
              ...prev,
              [sectionId]: productsData
            }));
          } catch (err) {
            console.error('Error al recargar productos:', err);
          }
        };
        
        loadProducts(selectedSection.section_id);
      }
    } finally {
      setIsLoading(false);
    }
  };

  // ----- EFECTOS -----
  
  // Precargar datos cuando se carga el dashboard
  useEffect(() => {
    if (categories.length > 0 && !isLoading) {
      console.log("Iniciando precarga de datos para todas las categorías...");
      const preloadAllData = async () => {
        const activeCategories = categories.filter(cat => cat.status === 1);
        console.log(`Precargando datos para ${activeCategories.length} categorías activas`);
        
        // Precargar todas las secciones primero
        for (const category of activeCategories) {
          if (!sections[category.category_id]) {
            try {
              console.log(`Precargando secciones para categoría ${category.name}`);
              const sectionsData = await fetchSections(category.category_id);
              
              setSections(prev => ({
                ...prev,
                [category.category_id]: sectionsData
              }));
              
              // Precargar productos para cada sección
              const activeSections = sectionsData.filter((sec: Section) => sec.status === 1);
              for (const section of activeSections) {
                if (!products[section.section_id]) {
                  console.log(`Precargando productos para sección ${section.name}`);
                  try {
                    const productsData = await fetchProducts(section.section_id);
                    setProducts(prev => ({
                      ...prev,
                      [section.section_id]: productsData
                    }));
                  } catch (error) {
                    console.error(`Error al precargar productos para sección ${section.name}:`, error);
                  }
                }
              }
            } catch (err) {
              console.error(`Error al precargar secciones para categoría ${category.name}:`, err);
            }
          }
        }
        console.log("Precarga de datos completada.");
      };
      
      preloadAllData();
    }
  }, [categories, isLoading]);

  // Efecto para cargar datos iniciales al autenticarse
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      try {
        const clientData = await fetchClientData();
        const categoriesData = await fetchCategories();

        setClient(clientData);
        setCategories(categoriesData);
        setSelectedCategory(categoriesData[0] || null);
        
        console.log("Datos del cliente:", clientData);
        console.log("Logo principal:", clientData.main_logo);
        console.log("Logo URL completa:", `/images/main_logo/${clientData.main_logo}`);
        
      } catch (err: any) {
        setError(err.message || 'Error desconocido al cargar datos');
      } finally {
        setIsLoading(false);
      }
    };
    
    if (status === 'authenticated') loadData();
  }, [status]);

  // Función para manejar el click en una categoría
  const handleCategoryClick = async (categoryId: number) => {
    const isExpanded = expandedCategories[categoryId];
    
    // Actualizar el estado de expansión
    setExpandedCategories(prev => ({
      ...prev,
      [categoryId]: !isExpanded
    }));
    
    // Si estamos expandiendo y no tenemos las secciones cargadas, cargarlas
    if (!isExpanded && !sections[categoryId]) {
      // Marcar como cargando
      setLoadingSections(prev => ({
        ...prev,
        [categoryId]: true
      }));
      
      try {
        const sectionsData = await fetchSections(categoryId);
        
        // Actualizar las secciones
        setSections(prev => ({
          ...prev,
          [categoryId]: sectionsData
        }));
      } catch (error) {
        console.error('Error al cargar secciones:', error);
        toast.error('Error al cargar las secciones');
      } finally {
        setLoadingSections(prev => ({
          ...prev,
          [categoryId]: false
        }));
      }
    }
    
    // Hacer scroll automático a la sección expandida después de un breve retraso
    setTimeout(() => {
      if (!isExpanded) {
        const element = document.getElementById(`category-${categoryId}`);
        if (element) {
          element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }
    }, 100);
  };

  // Función para manejar el click en una sección
  const handleSectionClick = async (sectionId: number) => {
    const isExpanded = expandedSections[sectionId];
    
    // Actualizar el estado de expansión
    setExpandedSections(prev => ({
      ...prev,
      [sectionId]: !isExpanded
    }));
    
    // Si estamos expandiendo y no tenemos los productos cargados, cargarlos
    if (!isExpanded && !products[sectionId]) {
      // Marcar como cargando
      setLoadingProducts(prev => ({
        ...prev,
        [sectionId]: true
      }));
      
      try {
        const productsData = await fetchProducts(sectionId);
        
        // Actualizar los productos
        setProducts(prev => ({
          ...prev,
          [sectionId]: productsData
        }));
    } catch (error) {
        console.error('Error al cargar productos:', error);
        toast.error('Error al cargar los productos');
    } finally {
        setLoadingProducts(prev => ({
          ...prev,
          [sectionId]: false
        }));
      }
    }
    
    // Hacer scroll automático a la sección expandida después de un breve retraso
    setTimeout(() => {
      if (!isExpanded) {
        const element = document.getElementById(`section-${sectionId}`);
        if (element) {
          element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }
    }, 100);
  };

  // Funciones para la navegación entre vistas
  const navigateToCategory = (categoryId: number) => {
    const category = categories.find(c => c.category_id === categoryId);
    if (category) {
      setSelectedCategory(category);
      setCurrentView('sections');
      
      // Cargar secciones si no están cargadas
      if (!sections[categoryId]) {
        handleCategoryClick(categoryId);
      }
    }
  };
  
  const navigateToSection = (sectionId: number) => {
    if (!selectedCategory) return;
    
    const section = sections[selectedCategory.category_id]?.find(s => s.section_id === sectionId);
    if (section) {
      setSelectedSection(section);
      setCurrentView('products');
      
      // Cargar productos si no están cargados
      if (!products[sectionId]) {
        handleSectionClick(sectionId);
      }
    }
  };
  
  const navigateBack = () => {
    if (currentView === 'products') {
      setCurrentView('sections');
      setSelectedProduct(null);
    } else if (currentView === 'sections') {
      setCurrentView('categories');
      setSelectedSection(null);
    }
  };

  // Función para actualizar la visibilidad de una categoría
  const toggleCategoryVisibility = async (categoryId: number, currentStatus: number) => {
    setIsUpdatingVisibility(categoryId);
    try {
      // Llamar a la API para actualizar el estado
      await updateCategoryVisibility(categoryId, currentStatus === 1 ? 0 : 1);
      
      // Actualizar estado local
      setCategories(prev => 
        prev.map(cat => 
          cat.category_id === categoryId 
            ? { ...cat, status: currentStatus === 1 ? 0 : 1 } 
            : cat
        )
      );
      
      toast.success('Estado actualizado correctamente');
      } catch (error) {
      console.error('Error al actualizar visibilidad:', error);
      toast.error('Error al actualizar el estado');
    } finally {
      setIsUpdatingVisibility(null);
    }
  };

  // Función para actualizar la visibilidad de una sección
  const toggleSectionVisibility = async (sectionId: number, currentStatus: number) => {
    setIsUpdatingVisibility(sectionId);
    try {
      // Llamar a la API para actualizar el estado
      await updateSectionVisibility(sectionId, currentStatus === 1 ? 0 : 1);
      
      // Actualizar estado local
      setSections(prev => {
        const updated = {...prev};
        
        // Actualizar todas las secciones que coincidan con sectionId
        Object.keys(updated).forEach(categoryId => {
          if (updated[Number(categoryId)]) {
            updated[Number(categoryId)] = updated[Number(categoryId)].map(section => 
              section.section_id === sectionId 
                ? { ...section, status: currentStatus === 1 ? 0 : 1 } 
                : section
            );
          }
        });
        
        return updated;
      });
      
      toast.success('Estado actualizado correctamente');
    } catch (error) {
      console.error('Error al actualizar visibilidad:', error);
      toast.error('Error al actualizar el estado');
    } finally {
      setIsUpdatingVisibility(null);
    }
  };

  // Función para actualizar la visibilidad de un producto
  const toggleProductVisibility = async (productId: number, currentStatus: number) => {
    setIsUpdatingVisibility(productId);
    try {
      // Llamar a la API para actualizar el estado
      await updateProductVisibility(productId, currentStatus === 1 ? 0 : 1);
      
      // Actualizar estado local
      setProducts(prev => {
        const updated = {...prev};
        
        // Actualizar todos los productos que coincidan con productId
        Object.keys(updated).forEach(sectionId => {
          if (updated[Number(sectionId)]) {
            updated[Number(sectionId)] = updated[Number(sectionId)].map(product => 
              product.product_id === productId 
                ? { ...product, status: currentStatus === 1 ? 0 : 1 } 
                : product
            );
          }
        });
        
        return updated;
      });
      
      toast.success('Estado actualizado correctamente');
    } catch (error) {
      console.error('Error al actualizar visibilidad:', error);
      toast.error('Error al actualizar el estado');
    } finally {
      setIsUpdatingVisibility(null);
    }
  };

  // ----- RENDERIZADO -----
  
  // Mostrar indicador de carga mientras se cargan los datos
  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-full py-12">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-indigo-600"></div>
        </div>
    )
  }

  // Mostrar mensaje de error si hay alguno
  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded relative">
        <strong className="font-bold">Error:</strong>
        <span className="block sm:inline"> {error}</span>
      </div>
    )
  }

  // Función para editar una categoría
  const handleEditCategory = (category: Category) => {
    setEditingCategory({
      id: category.category_id,
      name: category.name
    });
    setEditCategoryName(category.name);
    setEditImagePreview(category.image ? getImagePath(category.image, 'categories') : null);
    setIsEditModalOpen(true);
  };

  // Función para eliminar una categoría
  const handleDeleteCategory = (categoryId: number) => {
    setCategoryToDelete(categoryId);
    setIsDeleteModalOpen(true);
  };
  
  // Generar items para el componente de breadcrumbs
  const getBreadcrumbItems = () => {
    const items = [
      { 
        id: 'categories', 
        name: 'Categorías', 
        onClick: () => setCurrentView('categories'), 
        current: currentView === 'categories' 
      }
    ];
    
    if (currentView === 'sections' && selectedCategory) {
      items.push({ 
        id: `category-${selectedCategory.category_id}`, 
        name: selectedCategory.name, 
        onClick: () => {}, 
        current: true 
      });
    }
    
    if (currentView === 'products' && selectedCategory && selectedSection) {
      items.push({ 
        id: `category-${selectedCategory.category_id}`, 
        name: selectedCategory.name, 
        onClick: () => navigateBack(), 
        current: false 
      });
      
      items.push({ 
        id: `section-${selectedSection.section_id}`, 
        name: selectedSection.name, 
        onClick: () => {}, 
        current: true 
      });
    }
    
    return items;
  };

  // Función para alternar el modo de reordenamiento
  const toggleReorderMode = () => {
    setIsReorderModeActive(prev => !prev);
  };

  // Función para crear una nueva sección
  const handleCreateSection = async (newSection: any) => {
    // Actualizar el estado local para incluir la nueva sección
    setSections(prev => ({
      ...prev,
      [selectedCategory!.category_id]: [
        ...(prev[selectedCategory!.category_id] || []),
        newSection
      ]
    }));
    
    // Si es la primera sección, establecerla como seleccionada
    if ((sections[selectedCategory!.category_id] || []).length === 0) {
      setSelectedSection(newSection);
      await fetchProducts(newSection.section_id);
    }

    // Mostrar mensaje de éxito
    toast.success('Sección creada con éxito');
  };
  
  // Función para crear un nuevo producto
  const handleCreateProduct = async (newProduct: any) => {
    // Actualizar el estado local para incluir el nuevo producto
    setProducts(prev => ({
      ...prev,
      [selectedSection!.section_id]: [
        ...(prev[selectedSection!.section_id] || []),
        newProduct
      ]
    }));
    
    // Mostrar mensaje de éxito
    toast.success('Producto creado con éxito');
  };
  
  // Función para editar una sección
  const handleEditSection = (section: Section) => {
    setEditingSection({
      id: section.section_id,
      name: section.name
    });
    setIsEditSectionModalOpen(true);
  };

  // Función para eliminar una sección
  const handleDeleteSection = (sectionId: number) => {
    setSectionToDelete(sectionId);
    setIsDeleteSectionModalOpen(true);
  };
  
  // Función para editar un producto
  const handleEditProduct = (product: Product) => {
    setEditingProduct({
      id: product.product_id,
      name: product.name
    });
    setIsEditProductModalOpen(true);
  };

  // Función para eliminar un producto
  const handleDeleteProduct = (productId: number) => {
    setProductToDelete(productId);
    setIsDeleteProductModalOpen(true);
  };

  // Implementación local de deleteSection
  const deleteSection = async (sectionId: number): Promise<boolean> => {
    if (!client?.id) return false;
    
    try {
      // Usar el hook useSections para eliminar la sección
      const { deleteSection } = useSections(client.id);
      
      // Buscar la categoría a la que pertenece esta sección
      let categoryId: number | null = null;
      for (const [catId, sectionList] of Object.entries(sections)) {
        if (sectionList.some(s => s.section_id === sectionId)) {
          categoryId = parseInt(catId);
          break;
        }
      }
      
      if (!categoryId) {
        console.error('No se encontró categoría para la sección', sectionId);
        return false;
      }
      
      const result = await deleteSection(categoryId, sectionId);
      return result;
    } catch (error) {
      console.error('Error en deleteSection:', error);
      return false;
    }
  };

  // Implementación local de deleteProduct
  const deleteProduct = async (productId: number): Promise<boolean> => {
    try {
      // Usar el hook useProducts para eliminar el producto
      const { deleteProduct } = useProducts();
      await deleteProduct(productId);
      return true;
    } catch (error) {
      console.error('Error en deleteProduct:', error);
      return false;
    }
  };

  return (
    <>
      <TopNavbar 
        isReorderModeActive={isReorderModeActive}
        onToggleReorderMode={toggleReorderMode}
      />
      <div className="max-w-6xl mx-auto pt-2">
        {/* Breadcrumbs y botón de acción */}
        <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-2 pb-2 px-4">
          {/* Breadcrumbs */}
          <div>
            <Breadcrumbs items={getBreadcrumbItems()} />
          </div>
              
          {/* Botón de acción según la vista */}
          <div>
            {currentView === 'categories' && (
            <div className="flex items-center">
              <button
                onClick={() => {
                  // Activar la vista previa (esta función activa el FloatingPhonePreview)
                  const event = new CustomEvent('toggle-preview');
                  window.dispatchEvent(event);
                }}
                className="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
              >
                <DevicePhoneMobileIcon className="h-4 w-4 mr-1" />
                Live Preview
              </button>
            </div>
            )}
            
            {currentView === 'sections' && selectedCategory && (
            <button
                onClick={() => setIsNewSectionModalOpen(true)}
                className="inline-flex items-center px-3 py-2 border border-indigo-300 text-sm leading-4 font-medium rounded-md text-indigo-700 bg-indigo-50 hover:bg-indigo-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 shadow-sm"
            >
                <PlusIcon className="h-4 w-4 mr-1" />
                Nueva Sección
            </button>
            )}
            
            {currentView === 'products' && selectedSection && (
                            <button
                onClick={() => setIsNewProductModalOpen(true)}
                className="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
              >
                <PlusIcon className="h-4 w-4 mr-1" />
                Nuevo Producto
                            </button>
                )}
                        </div>
          </div>
          
        {/* Contenido principal según la vista */}
        <div className="space-y-3" ref={sectionListRef}>
          {currentView === 'categories' && (
            <div className="w-full px-4">
              <div className="mb-4">
                <button
                  onClick={() => setIsNewCategoryModalOpen(true)}
                  className="w-full flex items-center justify-center px-4 py-2 border border-indigo-300 text-sm font-medium rounded-md text-indigo-700 bg-indigo-50 hover:bg-indigo-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 shadow-sm"
                >
                  <PlusIcon className="h-5 w-5 mr-2" />
                  Nueva Categoría
                </button>
              </div>
              <CategoryTable
                categories={categories}
                expandedCategories={expandedCategories}
                onCategoryClick={handleCategoryClick}
                onEditCategory={handleEditCategory}
                onDeleteCategory={handleDeleteCategory}
                onToggleVisibility={toggleCategoryVisibility}
                isUpdatingVisibility={isUpdatingVisibility}
                onReorderCategory={handleReorderCategory}
              />
            </div>
          )}
          
          {currentView === 'sections' && selectedCategory && (
            <div className="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4 px-4">
              <div className="w-full md:w-2/3">
                <div className="mb-4">
                  <button
                    onClick={() => setIsNewSectionModalOpen(true)}
                    className="w-full flex items-center justify-center px-4 py-2 border border-indigo-300 text-sm font-medium rounded-md text-indigo-700 bg-indigo-50 hover:bg-indigo-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 shadow-sm"
                  >
                    <PlusIcon className="h-5 w-5 mr-2" />
                    Añadir nueva sección a {selectedCategory.name}
                  </button>
                </div>
                {sections[selectedCategory.category_id] ? (
                  <SectionTable 
                    sections={sections[selectedCategory.category_id]}
                    expandedSections={expandedSections}
                    onSectionClick={handleSectionClick}
                    onBackClick={navigateBack}
                    categoryName={selectedCategory.name}
                    onEditSection={(sectionToEdit) => {
                      handleEditSection(sectionToEdit as unknown as Section);
                    }}
                    onDeleteSection={handleDeleteSection}
                    onToggleVisibility={toggleSectionVisibility}
                    isUpdatingVisibility={isUpdatingVisibility}
                    onReorderSection={(sourceIndex, destinationIndex) => {
                      // Implementar reordenamiento de secciones
                      console.log('Reordenar secciones', sourceIndex, destinationIndex);
                    }}
                  />
                ) : (
                  <div className="flex justify-center items-center h-40 bg-white rounded-lg border border-gray-200">
                    <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-600"></div>
                  </div>
                )}
              </div>
              <div className="w-full md:w-1/3">
                <FloatingPhonePreview 
                  clientName={client?.name || "Mi Restaurante"}
                  clientMainLogo={client?.main_logo || undefined}
                  categories={categories.filter(cat => cat.status === 1).map(cat => ({
                    id: cat.category_id,
                    category_id: cat.category_id,
                    name: cat.name,
                    image: cat.image ? getImagePath(cat.image, 'categories') : undefined,
                    sections: sections[cat.category_id]?.filter(sec => sec.status === 1).map(sec => ({
                      id: sec.section_id,
                      name: sec.name,
                      image: sec.image || undefined
                    })) || []
                  })) as FloatingPhoneCategory[]}
                  selectedCategory={selectedCategory ? {
                    id: selectedCategory.category_id,
                    name: selectedCategory.name,
                    image: selectedCategory.image ? getImagePath(selectedCategory.image, 'categories') : undefined
                  } : null}
                  selectedSection={selectedSection ? {
                    id: selectedSection.section_id,
                    name: selectedSection.name,
                    image: selectedSection.image ? getImagePath(selectedSection.image, 'sections') : undefined
                  } : null}
                />
              </div>
            </div>
          )}
          
          {currentView === 'products' && selectedCategory && selectedSection && (
            <div className="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4 px-4">
              <div className="w-full md:w-2/3">
                <div className="mb-4">
                  <button
                    onClick={() => setIsNewProductModalOpen(true)}
                    className="w-full flex items-center justify-center px-4 py-2 border border-indigo-300 text-sm font-medium rounded-md text-indigo-700 bg-indigo-50 hover:bg-indigo-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 shadow-sm"
                  >
                    <PlusIcon className="h-5 w-5 mr-2" />
                    Añadir nuevo producto a {selectedSection.name}
                  </button>
                </div>
                {products[selectedSection.section_id] ? (
                  <ProductTable 
                    products={products[selectedSection.section_id]}
                    onBackClick={navigateBack}
                    sectionName={selectedSection.name}
                    onEditProduct={(productToEdit) => {
                      handleEditProduct(productToEdit as unknown as Product);
                    }}
                    onDeleteProduct={handleDeleteProduct}
                    onToggleVisibility={toggleProductVisibility}
                    isUpdatingVisibility={isUpdatingVisibility}
                    onReorderProduct={(sourceIndex, destinationIndex) => {
                      // Implementar reordenamiento de productos
                      console.log('Reordenar productos', sourceIndex, destinationIndex);
                    }}
                  />
                ) : (
                  <div className="flex justify-center items-center h-40 bg-white rounded-lg border border-gray-200">
                    <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-600"></div>
                  </div>
                )}
              </div>
              <div className="w-full md:w-1/3">
                <FloatingPhonePreview 
                  clientName={client?.name || "Mi Restaurante"}
                  clientMainLogo={client?.main_logo || undefined}
                  categories={categories.filter(cat => cat.status === 1).map(cat => ({
                    id: cat.category_id,
                    name: cat.name,
                    image: cat.image ? getImagePath(cat.image, 'categories') : undefined,
                    sections: sections[cat.category_id]?.filter(sec => sec.status === 1).map(sec => ({
                      id: sec.section_id,
                      name: sec.name,
                      image: sec.image ? getImagePath(sec.image, 'sections') : undefined,
                      products: products[sec.section_id]?.filter(prod => prod.status === 1).map(prod => ({
                        id: prod.product_id,
                        name: prod.name,
                        image: prod.image ? getImagePath(prod.image, 'products') : undefined,
                        price: prod.price,
                        description: prod.description ?? undefined
                      })) || []
                    })) || []
                  })) as FloatingPhoneCategory[]}
                />
              </div>
            </div>
          )}
      </div>
      
        {/* Secciones expandidas para categorías */}
        {currentView === 'categories' && categories.map(category => {
          if (!expandedCategories[category.category_id]) return null;
          
          return (
            <div 
              key={`category-${category.category_id}`}
              id={`category-${category.category_id}`}
              className="mt-4 pl-4 pr-4 border-l-2 border-indigo-100 max-w-[95%] mx-auto"
            >
              <div className="mb-4">
                <button
                  onClick={() => {
                    setSelectedCategory(category);
                    setIsNewSectionModalOpen(true);
                  }}
                  className="w-full flex items-center justify-center px-4 py-2 border border-teal-300 text-sm font-medium rounded-md text-teal-700 bg-teal-50 hover:bg-teal-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 shadow-sm"
                >
                  <PlusIcon className="h-5 w-5 mr-2" />
                  Nueva Sección
                </button>
              </div>
              <SectionTable 
                sections={sections[category.category_id] || []}
                expandedSections={expandedSections}
                onSectionClick={handleSectionClick}
                categoryName={category.name}
                onToggleVisibility={toggleSectionVisibility}
                isUpdatingVisibility={isUpdatingVisibility}
                onEditSection={(section) => handleEditSection(section as unknown as Section)}
                onDeleteSection={handleDeleteSection}
              />
              
              {/* Productos expandidos para secciones */}
              {sections[category.category_id]?.map(section => {
                if (!expandedSections[section.section_id]) return null;
                
                return (
                  <div 
                    key={`section-${section.section_id}`}
                    id={`section-${section.section_id}`}
                    className="mt-4 pl-4 pr-4 border-l-2 border-teal-100 max-w-[90%] mx-auto"
                  >
                    <div className="mb-4">
                      <button
                        onClick={() => {
                          setSelectedSection(section);
                          setIsNewProductModalOpen(true);
                        }}
                        className="w-full flex items-center justify-center px-4 py-2 border border-amber-300 text-sm font-medium rounded-md text-amber-700 bg-amber-50 hover:bg-amber-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-amber-500 shadow-sm"
                      >
                        <PlusIcon className="h-5 w-5 mr-2" />
                        Nuevo Producto
                      </button>
                    </div>
                    <ProductTable 
                      products={products[section.section_id] || []}
                      sectionName={section.name}
                      onToggleVisibility={toggleProductVisibility}
                      isUpdatingVisibility={isUpdatingVisibility}
                      onEditProduct={(productToEdit) => {
                        handleEditProduct(productToEdit as unknown as Product);
                      }}
                      onDeleteProduct={handleDeleteProduct}
                    />
                  </div>
                );
              })}
                    </div>
          );
        })}
        
        {/* Modal para crear categoría */}
        <NewCategoryModalComponent
          isOpen={isNewCategoryModalOpen}
          onClose={() => setIsNewCategoryModalOpen(false)}
          onCreateCategory={async (name: string, image: File) => {
            if (!client) return;
            
            const formData = new FormData();
            formData.append('name', name);
            formData.append('client_id', client.id.toString());
            
            if (image) {
              formData.append('image', image);
            }
            
            try {
              const response = await fetch('/api/categories', {
                method: 'POST',
                body: formData
              });
              
              if (!response.ok) {
                throw new Error('Error al crear la categoría');
              }
              
              const newCategory = await response.json();
              
              // Actualizar estado local
              setCategories(prev => [...prev, newCategory]);
              
              toast.success('Categoría creada correctamente');
            } catch (error) {
              console.error('Error al crear la categoría:', error);
              toast.error('Error al crear la categoría');
            }
          }}
        />
        
        {/* Modal para eliminar sección */}
        <DeleteSectionModal 
          isOpen={isDeleteSectionModalOpen}
          onClose={() => setIsDeleteSectionModalOpen(false)}
          sectionToDelete={sectionToDelete}
          deleteSection={deleteSection}
          isDeletingSection={isDeletingSection}
          selectedCategory={selectedCategory}
          setSections={setSections}
        />
        
        {/* Modal para eliminar producto */}
        <DeleteProductModal 
          isOpen={isDeleteProductModalOpen}
          onClose={() => setIsDeleteProductModalOpen(false)}
          productToDelete={productToDelete}
          deleteProduct={deleteProduct}
          isDeletingProduct={isDeletingProduct}
          selectedSection={selectedSection}
          setProducts={setProducts}
        />
        
        {/* Modal para editar producto */}
        <EditProductModal
          isOpen={isEditProductModalOpen}
          onClose={() => {
            setIsEditProductModalOpen(false);
            setEditingProduct(null);
          }}
          product={editingProduct as unknown as Product}
          client={client}
          onProductUpdated={(updatedProduct) => {
            // Actualizar estado local
            setProducts(prev => {
              const updated = {...prev};
              Object.keys(updated).forEach(sectionId => {
                if (updated[Number(sectionId)]) {
                  updated[Number(sectionId)] = updated[Number(sectionId)].map(product => 
                    product.product_id === updatedProduct.product_id 
                      ? updatedProduct 
                      : product
                  );
                }
              });
              return updated;
            });
            
            // Limpiar formulario y cerrar modal
            setIsEditProductModalOpen(false);
            setEditingProduct(null);
            
            toast.success('Producto actualizado correctamente');
          }}
        />

        {/* Modal para editar sección */}
        <EditSectionModal
          isOpen={isEditSectionModalOpen}
          onClose={() => {
            setIsEditSectionModalOpen(false);
            setEditingSection(null);
          }}
          section={editingSection as unknown as Section}
          client={client}
          onSectionUpdated={(updatedSection) => {
            // Actualizar estado local
            setSections(prev => {
              const updated = {...prev};
              Object.keys(updated).forEach(categoryId => {
                if (updated[Number(categoryId)]) {
                  updated[Number(categoryId)] = updated[Number(categoryId)].map(section => 
                    section.section_id === updatedSection.section_id 
                      ? updatedSection 
                      : section
                  );
                }
              });
              return updated;
            });
            
            // Limpiar formulario y cerrar modal
            setIsEditSectionModalOpen(false);
            setEditingSection(null);
            
            toast.success('Sección actualizada correctamente');
          }}
        />

        {/* Modal de nueva sección */}
        <NewSectionModal
          isOpen={isNewSectionModalOpen}
          onClose={() => setIsNewSectionModalOpen(false)}
          category={selectedCategory}
          client={client}
          onSectionCreated={handleCreateSection}
        />

        {/* Modal de nuevo producto */}
        <NewProductModal
          isOpen={isNewProductModalOpen}
          onClose={() => setIsNewProductModalOpen(false)}
          section={selectedSection}
          client={client}
          onProductCreated={handleCreateProduct}
        />
      </div>
      
      {/* Componente de vista previa móvil flotante */}
      <FloatingPhonePreview 
        clientName={client?.name} 
        clientLogo={client?.logo ? `/images/clients/${client.logo}` : undefined}
        clientMainLogo={client?.main_logo ? `/images/main_logo/${client.main_logo}` : undefined}
        categories={categories
          .filter(cat => cat.status === 1) // Solo categorías activas
          .map(cat => ({
            id: cat.category_id,
            category_id: cat.category_id,
            name: cat.name,
            image: cat.image ? getImagePath(cat.image, 'categories') : undefined,
            sections: sections[cat.category_id]?.filter(sec => sec.status === 1).map(sec => ({
              id: sec.section_id,
              name: sec.name,
              image: sec.image || undefined
            })) || []
          })) as FloatingPhoneCategory[]}
        selectedCategory={selectedCategory ? {
          id: selectedCategory.category_id,
          name: selectedCategory.name,
          image: selectedCategory.image ? getImagePath(selectedCategory.image, 'categories') : undefined
        } : null}
        selectedSection={selectedSection ? {
          id: selectedSection.section_id,
          name: selectedSection.name,
          image: selectedSection.image ? getImagePath(selectedSection.image, 'sections') : undefined
        } : null}
      />
    </>
  );
}
